This document is written in Japanese.<br>
If you can not understand Japanese and are eager to read this document, please register issues.<br>
I will translate this document in English if the issues are registered.<br>

= Introduction =

clione-sqlの使用方法です。
基本編、応用編に分かれています。<br>
開発を始めるには、まずは基本編に目を通しておけば充分でしょう。<br>
基本編の内容では対応できない問題が発生した場合には、応用編を読んで対応してください。<br>

=基本編=

==2WaySQL==
まずは簡単なサンプルを使用して、2WaySQLの概念を説明します。<br>
下記のようなsqlファイルを用意します。

[Sample.sql]
{{{
SELECT
    *
FROM
    TABLE1
WHERE
    FIELD1 = /* param1 */100
    AND FIELD2 = /* param2 */'AAA'
}}}

これを適切なパス(後述)に置き、Javaで次のように実装します。

{{{
import static tetz42.clione.SQLManager.*;
           :
    public List<Entity> findTable1ByParam1AndParam2(int param1, String param2) {
        return sqlManager().useFile(getClass(), "Sample.sql")
                .findAll( Entity.class, params("param1", param1).$("param2", param2) );
    }
}}}

すると、上記Sample.sqlは下記のように変換され、適切にparam1, 2の値がbindされて実行されます。
{{{
SELECT
    *
FROM
    TABLE1
WHERE
    FIELD1 = ?
    AND FIELD2 = ?
}}}
<br>
Sample.sqlのテンプレート内で使用されている「/`*` param1 `*`/」はANSIで定められたSQL文のコメントであるため、Sample1.sqlはそのまま通常のSQLとして実行することができます。このように、テンプレートでありながらも通常のSQL文としても扱える仕組みのことを、*2WaySQL* と言います。<br>
この仕組みによりclione-sqlでは、テンプレートとなるSQL文を実際に実行したり解析したりしながら開発＆リファクタリングすることが可能となります。<br>

==パラメタの値に応じたSQL文の変化==
SQLファイルで下記のように「=」の前にパラメタを記述すると、パラメタの値に合わせてSQL文が変化させることができます。
{{{
SELECT
    *
FROM
    TABLE1
WHERE
    FIELD1 /* param */= 100
}}}

paramがnullのときは、下記のように「IS NULL」に変化します。
{{{
SELECT
    *
FROM
    TABLE1
WHERE
    FIELD1 IS NULL
}}}
<br>
paramがListか配列で要素数が2以上の場合には、下記のようにIN句に変化します。
{{{
SELECT
    *
FROM
    TABLE1
WHERE
    FIELD1 IN (?, ?, ?, ?, ?)
}}}
※List or 配列の要素数が1のときには「=」に、0の時には「IS NULL」に変化します。<br>
<br>
上記のように動作するのは、パラメタを「=, IS, IN, <>, !=, IS NOT, NOT IN」等の比較演算子の前においた場合です。<br>
それ以外の「LIKE」等には対応していません。<br>
なお「<>」など否定の比較演算子の前にパラメタを置いた場合には、nullの時には「IS NOT NULL」に、Listか配列の時には「NOT IN」に、それぞれ変化します。

==SQLファイルの配置==
SQLファイルは基本的にクラスパスの通ったディレクトリ以下のどこかに配置します。
配置した場所のパスを、下記のように指定します。
{{{
import static tetz42.clione.SQLManager.*;
           :
        sqlManager().useFile("com/sql/Sample.sql")
                .find ...(省略)
    }
}}}
またSQLファイルをクラスと関連付けて配置したいときのために、SQLManager#useFileメソッドではClassオブジェクトをパラメタに渡せるようになっています。<br>
{{{
import static tetz42.clione.SQLManager.*;
           :
        sqlManager().useFile(SampleDao.class, "Sample.sql")
                .find ...(省略)
    }
}}}
上記の例では、例えば`SampleDao`のパッケージが「com.clione.dao」だったとすると、<br>
  * com/clione/dao/sql/`SampleDao`/Sample.sql
に配置されているとみなされます。つまり、
  * [渡されたClassオブジェクトのパッケージ]/sql/[クラス名]/[指定されたファイル名]
というパスだと解釈されますので、そのパスに適切にSQLファイルを置くようにしてください。

==ファイルを使用しないSQL==
SQLファイルを作成するほどでもない簡単なSQL文の場合には、下記のように直接実行することもできます。
{{{
import static tetz42.clione.SQLManager.*;
           :
    public void delete() {
        return sqlManager().useSQL("DELETE FROM TABLE1").update();
    }
}}}
もちろん、パラメタも使えます。
{{{
import static tetz42.clione.SQLManager.*;
           :
    public Entity findById(String id) {
        return sqlManager().useSQL("SELECT * from TABLE1 WHERE ID=/* id */")
                  .find( Entity.class, params("id", id) );
    }
}}}

==インデントベースの動的SQL==
clione-sqlの名前の由来は、「Clione-sql is Line and Indent Oriented, NEsted-structured, 2WaySQL library.」です。<br>
つまり「clione-sqlは行志向かつインデント志向で、再帰的な構造を持つ2WaySQLなライブラリです。」ってな感じです。<br>
ここではこの名前の由来となった、行志向かつインデント志向な動的SQLについて説明します。<br>


==その他のパラメタ修飾記号==

==様々なfindメソッド==

==INSERT, UPDATE, DELETEを実行するupdateメソッド==

==パラメタについて==
  * paramsメソッド
  * 条件bean使用
  * $, $e, $on

==コネクション==

==便利な補助機能(%C, %L)==

=応用編=

==SQLExecutor==
==文字列リテラル==
==nilの概念==
==propertiesファイル==
==%if-%elseif-%else==
==ブロック切替え==
==%include==
==%STR, %SQL==