This document is written in Japanese.<br>
If you can not understand Japanese and are eager to read this document, please register issues.<br>
I will translate this document in English if the issues are registered.<br>

= Introduction =

clione-sqlの使用方法です。
基本編、応用編に分かれています。<br>
開発を始めるには、まずは基本編に目を通しておけば充分でしょう。<br>
基本編の内容では対応できない問題が発生した場合には、応用編を読んで対応してください。<br>

=基本編=

==2WaySQL==
まずは簡単なサンプルを使用して、2WaySQLの概念を説明します。<br>
下記のようなsqlファイルを用意します。

[Sample.sql]
{{{
SELECT
    *
FROM
    TABLE1
WHERE
    FIELD1 = /* param1 */100
    AND FIELD2 = /* param2 */'AAA'
}}}

これを適切なパス(後述)に置き、Javaで次のように実装します。

{{{
import static tetz42.clione.SQLManager.*;
           :
    public List<Entity> findTable1ByParam1AndParam2(int param1, String param2) {
        return sqlManager().useFile(getClass(), "Sample.sql")
                .findAll( Entity.class, params("param1", param1).$("param2", param2) );
    }
}}}

すると、上記Sample.sqlは下記のように変換され、適切にparam1, 2の値がbindされて実行されます。
{{{
SELECT
    *
FROM
    TABLE1
WHERE
    FIELD1 = ?
    AND FIELD2 = ?
}}}
<br>
Sample.sqlのテンプレート内で使用されている「/`*` param1 `*`/」はANSIで定められたSQL文のコメントであるため、Sample1.sqlはそのまま通常のSQLとして実行することができます。このように、テンプレートでありながらも通常のSQL文としても扱える仕組みのことを、*2WaySQL* と言います。<br>
この仕組みによりclione-sqlでは、テンプレートとなるSQL文を実際に実行したり解析したりしながら開発＆リファクタリングすることが可能となります。<br>

==パラメタの値に応じたSQL文の変化==
SQLファイルで下記のように「=」の前にパラメタを記述すると、パラメタの値に合わせてSQL文を変化させることができます。
{{{
SELECT
    *
FROM
    TABLE1
WHERE
    FIELD1 /* param */= 100
}}}

paramがnullのときは、下記のように「IS NULL」に変化します。
{{{
SELECT
    *
FROM
    TABLE1
WHERE
    FIELD1 IS NULL
}}}
<br>
paramがListか配列で要素数が2以上の場合には、下記のようにIN句に変化します。
{{{
SELECT
    *
FROM
    TABLE1
WHERE
    FIELD1 IN (?, ?, ?, ?, ?)
}}}
※List or 配列の要素数が1のときには「=」に、0の時には「IS NULL」に変化します。<br>
<br>
上記のように動作するのは、パラメタを「=, IS, IN, <>, !=, IS NOT, NOT IN」等の比較演算子の前においた場合です。<br>
それ以外の「LIKE」等には対応していません。<br>
なお「<>」など否定の比較演算子の前にパラメタを置いた場合には、nullの時には「IS NOT NULL」に、Listか配列の時には「NOT IN」に、それぞれ変化します。

==SQLファイルの配置==
SQLファイルは基本的にクラスパスの通ったディレクトリ以下のどこかに配置します。
配置した場所のパスを、下記のように指定します。
{{{
import static tetz42.clione.SQLManager.*;
           :
        sqlManager().useFile("com/sql/Sample.sql")
                .find ...(省略)
    }
}}}
またSQLファイルをクラスと関連付けて配置したいときのために、SQLManager#useFileメソッドではClassオブジェクトをパラメタに渡せるようになっています。<br>
{{{
import static tetz42.clione.SQLManager.*;
           :
        sqlManager().useFile(SampleDao.class, "Sample.sql")
                .find ...(省略)
    }
}}}
上記の例では、例えば`SampleDao`のパッケージが「com.clione.dao」だったとすると、<br>
  * com/clione/dao/sql/`SampleDao`/Sample.sql
に配置されているとみなされます。つまり、
  * [渡されたClassオブジェクトのパッケージ]/sql/[クラス名]/[指定されたファイル名]
というパスだと解釈されますので、そのパスに適切にSQLファイルを置くようにしてください。

==ファイルを使用しないSQL==
SQLファイルを作成するほどでもない簡単なSQL文の場合には、下記のように直接実行することもできます。
{{{
import static tetz42.clione.SQLManager.*;
           :
    public void delete() {
        return sqlManager().useSQL("DELETE FROM TABLE1").update();
    }
}}}
もちろん、パラメタも使えます。
{{{
import static tetz42.clione.SQLManager.*;
           :
    public Entity findById(String id) {
        return sqlManager().useSQL("SELECT * from TABLE1 WHERE ID=/* id */")
                  .find( Entity.class, params("id", id) );
    }
}}}

==インデントベースの動的SQL==
clione-sqlの名前の由来は、「Clione-sql is Line and Indent Oriented, NEsted-structured, 2WaySQL library.」です。<br>
つまり「clione-sqlは行志向かつインデント志向で、再帰的な構造を持つ2WaySQLなライブラリです。」ってな感じです。<br>
ここではこの名前の由来となった、行志向かつインデント志向な動的SQLについて説明します。<br>
<br>
まずは下記のSQLファイルをご覧ください。
{{{
SELECT
    *
FROM
    people
WHERE
    age >= /* $age_from */25
    AND age <= /* $age_to */50
}}}
最初の例と比べると、パラメタに「$」という記号がついていることが分かると思います。<br>
これをclione-sqlでは *パラメタ修飾記号* と呼びます。<br>
下記のように、Javaソースでパラメタを指定するときには、パラメタ修飾記号は省略できます。
{{{
import static tetz42.clione.SQLManager.*;
        :
    public List<Person> findAllByAge(Integer ageFrom, Integer ageTo) throws SQLException {
        return sqlManager().useFile(getClass(), "Select.sql")
                .findAll(Person.class, params("age_from", ageFrom).$("age_to", ageTo));
    }
}}}
なお、パラメタ修飾記号を省略せずに書いても正常に動作しますが、内部的にはパラメタ修飾記号は除去されます。<br>
<br>
パラメタ修飾記号には幾つか種類があり、それぞれで意味が違います。<br>
「$」は「パラメタの値がnullだったら、行ごと削除する」という意味になります。<br>
よって、もしパラメタage_fromがnullだった場合、SQL文は下記のように変換されます。
{{{
SELECT
    *
FROM
    people
WHERE
    age <= ?
}}}
区切りの「AND」も除去されて正しいSQL文になっていることに気がついたでしょうか？<br>
これはclione-sqlが自動的に行っています。<br>
<br>
さて、age_from, age_to共にnullだった場合はどう変換されるでしょうか？<br>
答えは下記です。
{{{
SELECT
    *
FROM
    people
}}}
見ての通り、WHERE句ごと除去されて正しいSQL文になっています。<br>
clione-sqlはどうやってこれらのことを実現しているのでしょうか？<br>
    :<br>
    :<br>
SQL文を書くときに、適切な単位で改行したり意味のある単位でインデントするのは、開発効率を上げるために多くの方がやっていることだと思います。<br>
clione-sqlではこれに着目して、<br>
  「正しく改行・インデントしてあるSQL文であれば、適切なパラメタ修飾子を付けるだけで安全かつ簡単に動的SQLを実現できる」<br>
という世界観を目指しています。<br>

なお、パラメタ修飾記号は、「!」を付与することで挙動を逆にすることもできます。
{{{
SELECT
    *
FROM
    people
WHERE
    SEX = 'female'
    AND age /* $!age */= 25
}}}
上記のように書いた場合、ageがnullの時には「age IS NULL」に変換され、ageに値が入っているときには行削除が行われます。<br>

==その他のパラメタ修飾記号==

==様々なfindメソッド==

==INSERT, UPDATE, DELETEを実行するupdateメソッド==

==パラメタについて==
  * paramsメソッド
  * 条件bean使用
  * $, $e, $on

==コネクション==

==補助関数(%concat, %C, %esc_like, %L)==
clione-sql0.4.0より、補助関数という概念が導入されました。<br>
パラメタ修飾記号だけでは対処が難しいことを実現します。<br>
補助関数には多数種類がありますが、基礎編では4つだけ紹介します。

===文字列連結補助関数(%concat, %C)===
「%concat」は文字列連結用の補助関数です。与えられた文字列とパラメタを連結して、一つのパラメタとしてまとめる働きがあります。<br>
サンプルとして、下記のSQLファイルをご覧ください。
{{{
SELECT
    COUNT(*)
FROM
    people
WHERE
    name like /* %concat('%', part_of_name, '%') */'%愛%'
}}}
これは下記のように変換されます。
{{{
SELECT
    COUNT(*)
FROM
    people
WHERE
    name like ?
}}}
part_of_nameの値が「希」だったとすると、bindされるパラメタの値は「%希%」になります。<br>
なお、括弧と括弧内の区切り文字「,」は省略することもできます。また%concatと打つのが面倒なときには、「%C」が同じ働きをする補助関数なので、こちらを使用してください。下記は上と全く同じ意味のSQLファイルです。
{{{
SELECT
    COUNT(*)
FROM
    people
WHERE
    name like /*%C '%' part_of_name '%' */'%愛%'
}}}

===LIKE句用補助関数(%esc_like, %L)===
LIKE句に値をbindするとき、値の中に'%'や'`_`'が含まれていると、LIKE句の記号として解釈されてしまうことが知られています。<br>
よって例えば「そうさ100%病気」をLIKE句で検索した場合、
  * そうさ100年間病気
  * そうさ100人、全部病気
など、想定とは違う検索結果も一緒に返ってきてしまいます。<br>
これは場合によっては、全く関係ない人に重要情報を見せてしまうようなセキュリティバグにつながりかねません。<br>
これを避けるため、ANSIでLIKE句のエスケープを下記のように定めています。<br>
下記の例では、LIKEで意味を持つ'%'の前に'#'を置いてエスケープしています。
{{{
SELECT
    COUNT(*)
FROM
    songs
WHERE
    lyrics like '%そうさ100#%病気%' escape '#'
}}}
※ 本来escapeに使う値はユーザが自由に決めて良いのですが、clione-sqlでは固定で「#」を使用しています。<br>
<br>
このエスケープを行う補助関数が%esc_likeです。<br>
下記のようにして使用します。
{{{
SELECT
    COUNT(*)
FROM
    songs
WHERE
    lyrics like /*%C '%' %esc_like(part_of_lyrics) '%' */'%そうさ100#%病気%' escape '#'
}}}
part_of_lyricsに渡した値が、自動的に'#'でエスケープされるようになります。<br>
<br>
補助関数「%L」を使うと上記は下記のように、より簡単に書くことができます。
{{{
SELECT
    COUNT(*)
FROM
    songs
WHERE
    lyrics like /*%L '%' part_of_lyrics '%' */'%そうさ100#%病気%'
}}}
つまり「%L」は、与えられたパラメタをエスケープし、%concatで連結した上で、SQL文に自動で「escape '#'」を付与します。<br>
また、パラメタの数が下記のように複数になっても、それぞれのパラメタに%esc_likeを適用するので大丈夫です。
{{{
SELECT
    COUNT(*)
FROM
    songs
WHERE
    lyrics like /*%L '%' pol1 '_' pol2 '%' */'%そうさ100#%病気%'
}}}
pol1が「君」、pol2が「1000%」だった場合、上記のパラメタは連結されて「%君`_`1000#%%」に、SQL文は下記のように変換されます。
{{{
SELECT
    COUNT(*)
FROM
    songs
WHERE
    lyrics like ? escape '#'
}}}
検索結果として、
 * 君は1000%
 * 君が1000%
 * 君も1000%
などが含まれたレコードの件数が取得できるはずです。<br>
※ 念のため：「`_`」はLIKE句では任意の一文字にマッチします。<br>
<br>
LIKE句に値をbindするときには、エスケープの必要がなければ%Cを、あれば%Lを、いちいち判断するのが面倒ならいつでも%Lを使用するようにしてください。

=応用編=

==コメント==
==文字列リテラル==
==行の連結==
==SQLExecutor==
==nilの概念==
==propertiesファイル==
==%if-%elseif-%else==
==ブロック切替え==
==%include==
==%STR, %SQL==